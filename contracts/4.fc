;; ;; {-
;; ;;   TASK 4 - Caesar Cipher
;; ;;   Implement a Caesar cipher encryption and decryption functions.
;; ;;   The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
;; ;;   where the text is encrypted in a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters and the last ASCII
;; ;;   character should go to the beginning. Return new text encoded in cell.
;; ;; -}

;; () recv_internal() {
;; }

;; ;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) "LDSLICEX"; ;; causes compile error
;; slice skip_bits(slice s, int len) asm "SDSKIPFIRST";
;; (slice, ()) ~skip_bits(slice s, int len) asm "SDSKIPFIRST";
;; int slice_data_empty?(slice s) asm "SDEMPTY";
;; ;; builder store_int(builder b, int x, int len) asm(x b len) "STIX"; ;; causes compile error
;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) "LDIX";
;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) "LDUX";
;; int slice_bits(slice s) asm "SBITS";
;; int slice_refs(slice s) asm "SREFS";
;; (int, int) slice_bits_refs(slice s) asm "SBITREFS";
;; forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";
;; int tuple_length (tuple t) asm "TLEN";
;; forall X -> (tuple) to_tuple (X x) asm "NOP";




;; ;; testable
;; (cell) caesar_cipher_encrypt(int shift, cell text) method_id {
;;   return caesar_helper(shift, text, -1);
;; }

;; ;; testable
;; (cell) caesar_cipher_decrypt(int shift, cell text) method_id {
;;   return caesar_helper(-1 * shift, text, -1);
;;   ;; int reverse_shift = - shift;
;;   ;; return caesar_cipher_encrypt(reverse_shift, text);
;; }





;; ;; added has_flag parameter
;; (cell) caesar_helper(int shift, cell text, int has_flag) method_id {
;;   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; debug for task 3
;;   ;; c1 = 1001  c2 = 110001  whole: 1001110001
;;   cell c2 = begin_cell()
;;             .store_uint(1, 1)
;;             .store_uint(1, 1)
;;             .store_uint(0, 1)
;;             .store_uint(0, 1)
;;             .store_uint(0, 1)
;;             .store_uint(1, 1)
;;             .end_cell();

;;   cell c1 = begin_cell()
;;             .store_ref(c2)
;;             .store_uint(1, 1)
;;             .store_uint(0, 1)
;;             .store_uint(0, 1)
;;             .store_uint(1, 1)
;;             .end_cell();

;;   tp = linked_list_to_tuple(c1);
;;   tuple sizes = empty_tuple();
;;   tuple cum_sizes = empty_tuple();
;;   (sizes, cum_sizes) = get_sizes_and_cum_sizes_tuples(tp);
;;   if(sizes.at(0) == 4){
;;     return text;
;;   } else {
;;     return begin_cell().end_cell();
;;   }


;;   ;; return tuple_to_linked_list(linked_list_to_tuple(text));
;;   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; debug for task 3

;;   slice cs = text.begin_parse();
;;   builder output = begin_cell();


;;   ;; handle the flag
;;   if(has_flag){
;;     int flag = cs~load_uint(32);
;;     ;; flag = cs~load_uint(32);
;;     ;; cs~load_uint(32);
;;     output = output.store_uint(0, 32);
;;   }
  


;;   ;; handle the ref
;;   if(cs.slice_refs_empty?() != -1){
;;     cell ref = cs~load_ref();
;;     cell ref_ceasar = caesar_helper(shift, ref, 0);
;;     output = output.store_ref(ref_ceasar);
;;   }



;;   ;; handle characters
;;   while(~ cs.slice_data_empty?()){
;;   ;; repeat(cs.slice_bits() % 8){
;;     int chr = cs~load_uint(8);

;;     if(chr >= 97){ ;; Encrypt lowercase characters
;;       if(chr <= 122){
;;         chr = ((chr + shift - 97) % 26) + 97;
;;       }
;;     } elseif (chr >= 65){ ;; Encrypt uppercase characters
;;       if(chr <= 90){
;;         chr = ((chr + shift - 65) % 26) + 65;
;;       }
;;     }

;;     output = output.store_uint(chr, 8);
;;   }

;;   return output.end_cell();
;; }

;; ;; ;; useful links:
;; ;; ;; https://docs.ton.org/develop/func/literals_identifiers#string-literals
;; ;; ;; https://docs.ton.org/develop/func/statements#operators
;; ;; ;; https://docs.ton.org/develop/smart-contracts/fees#how-to-calculate-fees
;; ;; ;; https://docs.ton.org/develop/howto/fees-low-level#computation-fees



;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; debug fot task 3

;; (slice) int_to_slice(int n, int n_size) method_id {
;;   slice output = begin_cell()
;;                   .store_uint(n, n_size)
;;                   .end_cell()
;;                   .begin_parse();
;;   return output;
;; }

;; (int) count_bits(int n) method_id {
;;   int count = 0;
;;   while (n > 0) {
;;       count += 1;
;;       n >>= 1; ;; Shift the number right by 1
;;   }
;;   return count;
;; }


;; (tuple, tuple) get_sizes_and_cum_sizes_tuples(tuple tp) method_id {
;;   tuple sizes = empty_tuple();
;;   tuple cum_sizes = empty_tuple();
;;   int i = 0;
;;   while(i < tp.tuple_length()){
;;     sizes~tpush(tp.at(i).slice_bits());
;;     if(i == 0){
;;       cum_sizes~tpush(sizes.at(0));
;;     } else {
;;       cum_sizes~tpush(cum_sizes.at(i - 1) + sizes.at(i));
;;     }
;;   }
;;   return (sizes, cum_sizes);
;; }


;; (slice, int) get_or_set_bit_in_slice(int i, int job, int int_value, slice cs) method_id {
;;   builder output_builder = begin_cell();
;;   int output_int = 0;
  
;;   int j = 0; 
;;   int cs_size = cs.slice_bits();
;;   while(j < cs_size){
;;     int read_int = cs~load_uint(1);
;;     if(j == i){
;;       if(job == -1){
;;         output_int = int_value;
;;       } else {
;;         output_int = read_int;
;;       }
;;       output_builder = output_builder.store_uint(output_int, 1);
;;     }
;;     output_builder = output_builder.store_uint(read_int, 1);
;;   }

;;   slice output_slice = output_builder.end_cell().begin_parse();
;;   return (output_slice, output_int);
;; }


;; (tuple, int) get_or_set_bit_in_tuple(int i, int job, int int_value, tuple tp, tuple sizes, tuple cum_sizes) method_id {
;;   tuple output_tp = empty_tuple();
;;   int output_int = 0;

;;   int chunk_i = 0;
;;   while(i > cum_sizes.at(chunk_i)){
;;     output_tp~tpush(tp.at(chunk_i));
;;     chunk_i += 1;
;;   }

;;   int j = sizes.at(chunk_i) - (cum_sizes.at(chunk_i) - i);
;;   slice target_chunk = tp.at(chunk_i);
;;   (target_chunk, output_int) = get_or_set_bit_in_slice(j, job, int_value, target_chunk); ;; job from parameters specifies being a get or set
;;   output_tp~tpush(target_chunk);

;;   chunk_i += 1;
;;   while(chunk_i < tp.tuple_length()){
;;     output_tp~tpush(tp.at(chunk_i));
;;     chunk_i += 1;
;;   }

;;   return (output_tp, output_int);
;; }


;; (tuple, slice) get_or_set_slice_in_tuple(int i, int job, slice slice_value, tuple tp, tuple sizes, tuple cum_sizes) method_id {
;;   builder output_builder = begin_cell();

;;   int total_size = cum_sizes.at(tp.tuple_length() - 1);
;;   int slice_value_size = slice_value.slice_bits();

;;   int j = 0;
;;   while(j < total_size){
;;     if((j >= i) & (j < i + slice_value_size)){
;;       int k = j - i;
;;       int read_int = 0;
;;       if(job == -1){
;;         (_, read_int) = get_or_set_bit_in_slice(k, 0, 0, slice_value); ;; get bit k from slice_value
;;         (tp, _) = get_or_set_bit_in_tuple(j, -1, read_int, tp, sizes, cum_sizes); ;; set read_int to bit j in tp
;;       } else {
;;         (_, read_int) = get_or_set_bit_in_tuple(j, 0, 0, tp, sizes, cum_sizes); ;; get bit j from tp
;;       }
;;       output_builder.store_uint(read_int, 1);
;;     }
;;     j += 1;
;;   }


;;   cell output_cell = output_builder.end_cell();
;;   return (tp, output_cell.begin_parse());
;;   ;;;;;;;;;;;;;;;; apparently the upper one is correct but lower one causes compile error
;;   ;; slice ouput_slice = output_builder
;;   ;;                     .end_cell()
;;   ;;                     .begin_parse();
;;   ;; return (tp, output_slice);
;; }

;; ;; tested: OK
;; (tuple) linked_list_to_tuple(cell linked_list) method_id {
;;   tuple tp = empty_tuple();
;;   while(-1){
;;     slice cs = linked_list.begin_parse();
;;     slice cs_only_data = cs.preload_bits(cs.slice_bits());
;;     tp~tpush(cs_only_data);

;;     if(cs.slice_refs_empty?()){
;;       return tp;
;;     } else {
;;       linked_list = cs~load_ref();
;;     }
;;   }
;;   return tp; ;; added to disable compiler error (debug)
;; }

;; ;; tested: OK
;; (cell) tuple_to_linked_list(tuple tp) method_id {
;;   slice last_cs = tp~tpop();
;;   cell linked_list = begin_cell()
;;                    .store_slice(last_cs)
;;                    .end_cell();
;;   while(tp.tuple_length() > 0){
;;     last_cs = tp~tpop();
;;     linked_list = begin_cell()
;;                   .store_slice(last_cs)
;;                   .store_ref(linked_list)
;;                   .end_cell();
;;   }
;;   return linked_list;
;; }


;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; debug fot task 3
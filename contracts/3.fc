;; {- 
;;   TASK 3 - Find and replace binary substring
;;   Binary string is represented as a cell linked list: string splitted to chunks,
;;   first chunk stored to the root cell, next one to the cell in ref and so on;
;;   each cell can have only one ref. 
;;   Write the method that find and replaces one flags in the binary string
;;   with another value. Flags and values can be can be of any length, but
;;   strictly up to 128 bits. The method must replace every flag it finds.
;;   Flag and the value to be replaced is guaranteed to be greater than 0.
;;   Lets give a simple example. We have the target flag 101110101 and the value
;;   to be written 111111111 as inputs, and a linked list of cells, in which the bit
;;   value of the first cell ends with ...10100001011, and in the ref we have cell that
;;   starts with 10101000111111...
;;   The output should be a linked list where the first
;;   cell ends with ...10100001111, and the second cell starts with 11111000111111...

;; -}
;; ;; target          endWith    startWith         
;; ;; 101110101       1010000101110101000111111
;; ;; 111111111       1010000111111111000111111
;; ;;

() recv_internal() {
}

(int) tlen(tuple t) asm "TLEN";
;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) "LDSLICEX"; ;; causes compile error
slice skip_bits(slice s, int len) asm "SDSKIPFIRST";
(slice, ()) ~skip_bits(slice s, int len) asm "SDSKIPFIRST";
int slice_data_empty?(slice s) asm "SDEMPTY";
;; builder store_int(builder b, int x, int len) asm(x b len) "STIX"; ;; causes compile error
(slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) "LDIX";
(slice, int) ~load_uint(slice s, int len) asm( -> 1 0) "LDUX";
int slice_bits(slice s) asm "SBITS";
int slice_refs(slice s) asm "SREFS";
(int, int) slice_bits_refs(slice s) asm "SBITREFS";
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";
int tuple_length (tuple t) asm "TLEN";
forall X -> (tuple) to_tuple (X x) asm "NOP";



;; testable
(cell) find_and_replace(int flag, int value, cell linked_list) method_id {
  tuple tp = linked_list_to_tuple(linked_list);
  (tuple sizes, tuple cum_sizes) = get_sizes_and_cum_sizes_tuples(tp);
  int total_size = cum_sizes.at(tp.tuple_length() - 1);
  int flag_size = count_bits(flag);

  int i = 0;
  while(i <= (total_size - flag_size)){
    slice empty_slice = "";
    ;; get slice at index i
    ;; (tuple temp_tp, slice check) = get_or_set_slice_in_tuple(i, 0, empty_slice, tp, sizes, cum_sizes); ;; commented as debug
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;debug
    slice check = "";
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;debug
    int int_from_check = check~load_uint(flag_size);
    if(flag == int_from_check){
      slice value_to_slice = int_to_slice(value, flag_size);
      ;; set value as a replacement for flag
      ;; (tp, slice temp_slice) = get_or_set_slice_in_tuple(i, -1, value_to_slice, tp, sizes, cum_sizes); ;; commented as debug
      i += flag_size;
    } else {
      i += 1;
    }
  }

  cell output_linked_list = tuple_to_linked_list(tp);
  return output_linked_list;
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; helper functions:

(slice) int_to_slice(int n, int n_size) method_id {
  slice output = begin_cell()
                  .store_uint(n, n_size)
                  .end_cell()
                  .begin_parse();
  return output;
}

(int) count_bits(int n) method_id {
  int count = 0;
  while (n > 0) {
      count += 1;
      n >>= 1; ;; Shift the number right by 1
  }
  return count;
}

;; first: sizes, second: cum_sizes
(tuple, tuple) get_sizes_and_cum_sizes_tuples(tuple tp) method_id {
  tuple sizes = empty_tuple();
  tuple cum_sizes = empty_tuple();
  int i = 0;
  while(i < tp.tuple_length()){
    sizes~tpush(tp.at(i).slice_bits());
    if(i == 0){
      cum_sizes~tpush(sizes.at(0));
    } else {
      cum_sizes~tpush(cum_sizes.at(i - 1) + sizes.at(i));
    }
  }
  return (sizes, cum_sizes);
}

;; job = -1 for set and 0 for get, leave value = 0 when doesn't exist
(slice, int) get_or_set_bit_in_slice(int i, int job, int int_value, slice cs) method_id {
  builder output_builder = begin_cell();
  int output_int = 0;
  
  int j = 0; 
  int cs_size = cs.slice_bits();
  while(j < cs_size){
    int read_int = cs~load_uint(1);
    if(j == i){
      if(job == -1){
        output_int = int_value;
      } else {
        output_int = read_int;
      }
      output_builder = output_builder.store_uint(output_int, 1);
    }
    output_builder = output_builder.store_uint(read_int, 1);
  }

  slice output_slice = output_builder.end_cell().begin_parse();
  return (output_slice, output_int);
}

;; job = -1 for set and 0 for get, leave value = 0 when doesn't exist
(tuple, int) get_or_set_bit_in_tuple(int i, int job, int int_value, tuple tp, tuple sizes, tuple cum_sizes) method_id {
  tuple output_tp = empty_tuple();
  int output_int = 0;

  int chunk_i = 0;
  while(i > cum_sizes.at(chunk_i)){
    output_tp~tpush(tp.at(chunk_i));
    chunk_i += 1;
  }

  int j = sizes.at(chunk_i) - (cum_sizes.at(chunk_i) - i);
  slice target_chunk = tp.at(chunk_i);
  (target_chunk, output_int) = get_or_set_bit_in_slice(j, job, int_value, target_chunk); ;; job from parameters specifies being a get or set
  output_tp~tpush(target_chunk);

  chunk_i += 1;
  while(chunk_i < tp.tuple_length()){
    output_tp~tpush(tp.at(chunk_i));
    chunk_i += 1;
  }

  return (output_tp, output_int);
}

;; job = -1 for set and 0 for get, leave value = 0 when doesn't exist
(tuple, slice) get_or_set_slice_in_tuple(int i, int job, slice slice_value, tuple tp, tuple sizes, tuple cum_sizes) method_id {
  builder output_builder = begin_cell();

  ;; int total_size = cum_sizes.at(tp.tuple_length() - 1);
  ;; int slice_value_size = slice_value.slice_bits();

  ;; int j = 0;
  ;; while(j < total_size){
  ;;   if((j >= i) & (j < i + slice_value_size)){
  ;;     int k = j - i;
  ;;     int read_int = 0;
  ;;     if(job == -1){
  ;;       (_, read_int) = get_or_set_bit_in_slice(k, 0, 0, slice_value); ;; get bit k from slice_value
  ;;       (tp, _) = get_or_set_bit_in_tuple(j, -1, read_int, tp, sizes, cum_sizes); ;; set read_int to bit j in tp
  ;;     } else {
  ;;       (_, read_int) = get_or_set_bit_in_tuple(j, 0, 0, tp, sizes, cum_sizes); ;; get bit j from tp
  ;;     }
  ;;     output_builder.store_uint(read_int, 1);
  ;;   }
  ;;   j += 1;
  ;; }


  slice ouput_slice = output_builder.end_cell().begin_parse();
  return (tp, output_slice);
}

(tuple) linked_list_to_tuple(cell linked_list) method_id {
  tuple tp = empty_tuple();
  while(-1){
    slice cs = linked_list.begin_parse();
    slice cs_only_data = cs.preload_bits(cs.slice_bits());
    tp~tpush(cs_only_data);

    if(cs.slice_refs_empty?()){
      return tp;
    } else {
      linked_list = cs~load_ref();
    }
  }
}

(cell) tuple_to_linked_list(tuple tp) method_id {
  slice last_cs = tp~tpop();
  cell linked_list = begin_cell()
                   .store_slice(last_cs)
                   .end_cell();
  while(tp.tuple_length() > 0){
    last_cs = tp~tpop();
    linked_list = begin_cell()
                  .store_slice(last_cs)
                  .store_ref(linked_list)
                  .end_cell();
  }
  return linked_list;
}


;; useful links:
;; https://docs.ton.org/develop/func/cookbook#how-to-get-only-data-bits-from-a-slice-without-refs
;; https://docs.ton.org/develop/func/statements#until-loop
;; https://docs.ton.org/develop/func/statements#operators
;; https://docs.ton.org/develop/func/cookbook#how-to-define-your-own-modifying-method